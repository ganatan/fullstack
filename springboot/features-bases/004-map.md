# map – tous les cas de figure (Java)

Tous les exemples sont exécutables directement dans un contrôleur Spring Boot.

---

## Code

```java
package com.ganatan.starter.api.root;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
import java.util.concurrent.ConcurrentHashMap;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class RootController {

  @GetMapping("/")
  public Map<String, Object> root() {
    Map<String, String> hashMap          = mapHashMap();
    Map<String, String> linkedHashMap    = mapLinkedHashMap();
    Map<String, String> treeMap          = mapTreeMap();
    Map<String, String> concurrentMap    = mapConcurrentHashMap();
    Map<String, String> immutableOf      = mapImmutableOf();
    Map<String, String> immutableEntries = mapImmutableEntries();
    String getResult                     = mapGet();
    String getOrDefault                  = mapGetOrDefault();
    boolean containsKey                  = mapContainsKey();
    boolean containsValue                = mapContainsValue();
    List<String> entrySet                = mapIterateEntrySet();
    List<String> keySet                  = mapIterateKeySet();
    List<String> values                  = mapIterateValues();
    Map<String, Integer> computeIfAbsent = mapComputeIfAbsent();
    Map<String, Integer> merge           = mapMerge();
    Map<String, String> replaceAll       = mapReplaceAll();
    boolean nullKeyAllowed               = mapNullKey();
    int size                             = mapSize();
    Map<String, String> putIfAbsent      = mapPutIfAbsent();
    Map<String, String> remove           = mapRemove();

    return Map.ofEntries(
      Map.entry("application",              "springboot-starter"),
      Map.entry("status",                   "running"),
      Map.entry("java",                     System.getProperty("java.version")),
      Map.entry("map_hashmap",              hashMap.get("a")),
      Map.entry("map_linkedhashmap_order",  new ArrayList<>(linkedHashMap.keySet()).get(0)),
      Map.entry("map_treemap_firstkey",     new ArrayList<>(treeMap.keySet()).get(0)),
      Map.entry("map_concurrent",           concurrentMap.get("a")),
      Map.entry("map_immutable_of",         immutableOf.get("a")),
      Map.entry("map_immutable_entries",    immutableEntries.get("a")),
      Map.entry("map_get",                  getResult),
      Map.entry("map_get_or_default",       getOrDefault),
      Map.entry("map_contains_key",         containsKey),
      Map.entry("map_contains_value",       containsValue),
      Map.entry("map_entryset",             entrySet),
      Map.entry("map_keyset",               keySet),
      Map.entry("map_values",               values),
      Map.entry("map_compute_if_absent",    computeIfAbsent.get("hello")),
      Map.entry("map_merge",                merge.get("a")),
      Map.entry("map_replace_all",          replaceAll.get("a")),
      Map.entry("map_null_key",             nullKeyAllowed),
      Map.entry("map_size",                 size),
      Map.entry("map_put_if_absent",        putIfAbsent.get("a")),
      Map.entry("map_remove",               remove.containsKey("a"))
    );
  }

  // Cas 1 : HashMap — non ordonné, clé null autorisée
  static Map<String, String> mapHashMap() {
    Map<String, String> map = new HashMap<>();
    map.put("a", "alpha");
    map.put("b", "beta");
    map.put("c", "gamma");
    return map;
  }

  // Cas 2 : LinkedHashMap — conserve l'ordre d'insertion
  static Map<String, String> mapLinkedHashMap() {
    Map<String, String> map = new LinkedHashMap<>();
    map.put("first", "1");
    map.put("second", "2");
    map.put("third", "3");
    return map;
  }

  // Cas 3 : TreeMap — trié par ordre naturel des clés
  static Map<String, String> mapTreeMap() {
    Map<String, String> map = new TreeMap<>();
    map.put("banana", "yellow");
    map.put("apple", "red");
    map.put("cherry", "red");
    return map;
  }

  // Cas 4 : ConcurrentHashMap — thread-safe
  static Map<String, String> mapConcurrentHashMap() {
    Map<String, String> map = new ConcurrentHashMap<>();
    map.put("a", "alpha");
    map.put("b", "beta");
    return map;
  }

  // Cas 5 : Map.of — immutable, max 10 paires
  static Map<String, String> mapImmutableOf() {
    return Map.of("a", "alpha", "b", "beta", "c", "gamma");
  }

  // Cas 6 : Map.ofEntries — immutable, sans limite
  static Map<String, String> mapImmutableEntries() {
    return Map.ofEntries(
      Map.entry("a", "alpha"),
      Map.entry("b", "beta"),
      Map.entry("c", "gamma")
    );
  }

  // Cas 7 : get — retourne null si clé absente
  static String mapGet() {
    Map<String, String> map = new HashMap<>();
    map.put("a", "alpha");
    return map.get("a");
  }

  // Cas 8 : getOrDefault — valeur de repli si clé absente
  static String mapGetOrDefault() {
    Map<String, String> map = new HashMap<>();
    map.put("a", "alpha");
    return map.getOrDefault("z", "default");
  }

  // Cas 9 : containsKey
  static boolean mapContainsKey() {
    Map<String, String> map = new HashMap<>();
    map.put("a", "alpha");
    return map.containsKey("a");
  }

  // Cas 10 : containsValue
  static boolean mapContainsValue() {
    Map<String, String> map = new HashMap<>();
    map.put("a", "alpha");
    return map.containsValue("alpha");
  }

  // Cas 11 : itération via entrySet
  static List<String> mapIterateEntrySet() {
    Map<String, String> map = new LinkedHashMap<>();
    map.put("a", "alpha");
    map.put("b", "beta");
    List<String> result = new ArrayList<>();
    for (Map.Entry<String, String> entry : map.entrySet()) {
      result.add(entry.getKey() + "=" + entry.getValue());
    }
    return result;
  }

  // Cas 12 : itération via keySet
  static List<String> mapIterateKeySet() {
    Map<String, String> map = new LinkedHashMap<>();
    map.put("a", "alpha");
    map.put("b", "beta");
    return new ArrayList<>(map.keySet());
  }

  // Cas 13 : itération via values
  static List<String> mapIterateValues() {
    Map<String, String> map = new LinkedHashMap<>();
    map.put("a", "alpha");
    map.put("b", "beta");
    return new ArrayList<>(map.values());
  }

  // Cas 14 : computeIfAbsent — calcule et insère si clé absente
  static Map<String, Integer> mapComputeIfAbsent() {
    Map<String, Integer> map = new HashMap<>();
    map.computeIfAbsent("hello", k -> k.length());
    return map;
  }

  // Cas 15 : merge — fusionne une valeur existante
  static Map<String, Integer> mapMerge() {
    Map<String, Integer> map = new HashMap<>();
    map.put("a", 1);
    map.merge("a", 2, Integer::sum);
    return map;
  }

  // Cas 16 : replaceAll — transforme toutes les valeurs
  static Map<String, String> mapReplaceAll() {
    Map<String, String> map = new LinkedHashMap<>();
    map.put("a", "alpha");
    map.put("b", "beta");
    map.replaceAll((k, v) -> v.toUpperCase());
    return map;
  }

  // Cas 17 : clé null autorisée dans HashMap
  static boolean mapNullKey() {
    Map<String, String> map = new HashMap<>();
    map.put(null, "nullValue");
    return map.containsKey(null);
  }

  // Cas 18 : size
  static int mapSize() {
    Map<String, String> map = new HashMap<>();
    map.put("a", "alpha");
    map.put("b", "beta");
    map.put("c", "gamma");
    return map.size();
  }

  // Cas 19 : putIfAbsent — n'écrase pas si clé déjà présente
  static Map<String, String> mapPutIfAbsent() {
    Map<String, String> map = new HashMap<>();
    map.put("a", "alpha");
    map.putIfAbsent("a", "OVERWRITE");
    map.putIfAbsent("b", "beta");
    return map;
  }

  // Cas 20 : remove — supprime une entrée
  static Map<String, String> mapRemove() {
    Map<String, String> map = new HashMap<>();
    map.put("a", "alpha");
    map.put("b", "beta");
    map.remove("a");
    return map;
  }
}
```

---

## Test

```java
package com.ganatan.starter.api.root;

import static org.junit.jupiter.api.Assertions.*;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import org.junit.jupiter.api.Test;

class RootControllerTests {

  private static final String APP = "springboot-starter";
  private static final String STATUS = "running";
  private static final String JAVA_PROP = "java.version";

  // --- root() global ---

  @Test
  void root_shouldReturnMapWithAllExpectedKeysAndValues() {
    RootController controller = new RootController();
    Map<String, Object> result = controller.root();

    assertNotNull(result);
    assertEquals(23, result.size());

    assertEquals(APP, result.get("application"));
    assertEquals(STATUS, result.get("status"));
    assertEquals(System.getProperty(JAVA_PROP), result.get("java"));

    assertEquals("alpha", result.get("map_hashmap"));
    assertEquals("first", result.get("map_linkedhashmap_order"));
    assertEquals("apple", result.get("map_treemap_firstkey"));
    assertEquals("alpha", result.get("map_concurrent"));
    assertEquals("alpha", result.get("map_immutable_of"));
    assertEquals("alpha", result.get("map_immutable_entries"));
    assertEquals("alpha", result.get("map_get"));
    assertEquals("default", result.get("map_get_or_default"));
    assertEquals(true, result.get("map_contains_key"));
    assertEquals(true, result.get("map_contains_value"));
    assertEquals(List.of("a=alpha", "b=beta"), result.get("map_entryset"));
    assertEquals(List.of("a", "b"), result.get("map_keyset"));
    assertEquals(List.of("alpha", "beta"), result.get("map_values"));
    assertEquals(5, (Integer) result.get("map_compute_if_absent"));
    assertEquals(3, (Integer) result.get("map_merge"));
    assertEquals("ALPHA", result.get("map_replace_all"));
    assertEquals(true, result.get("map_null_key"));
    assertEquals(3, (Integer) result.get("map_size"));
    assertEquals("alpha", result.get("map_put_if_absent"));
    assertEquals(false, result.get("map_remove"));

    assertThrows(UnsupportedOperationException.class, () -> result.put("x", "y"));
  }

  // --- Cas 1 : mapHashMap ---

  @Test
  void mapHashMap_shouldContainExpectedEntries() {
    Map<String, String> result = RootController.mapHashMap();
    assertEquals("alpha", result.get("a"));
    assertEquals("beta", result.get("b"));
    assertEquals("gamma", result.get("c"));
    assertEquals(3, result.size());
  }

  // --- Cas 2 : mapLinkedHashMap ---

  @Test
  void mapLinkedHashMap_shouldPreserveInsertionOrder() {
    Map<String, String> result = RootController.mapLinkedHashMap();
    List<String> keys = new ArrayList<>(result.keySet());
    assertEquals("first", keys.get(0));
    assertEquals("second", keys.get(1));
    assertEquals("third", keys.get(2));
  }

  // --- Cas 3 : mapTreeMap ---

  @Test
  void mapTreeMap_shouldSortKeysByNaturalOrder() {
    Map<String, String> result = RootController.mapTreeMap();
    List<String> keys = new ArrayList<>(result.keySet());
    assertEquals("apple", keys.get(0));
    assertEquals("banana", keys.get(1));
    assertEquals("cherry", keys.get(2));
  }

  // --- Cas 4 : mapConcurrentHashMap ---

  @Test
  void mapConcurrentHashMap_shouldContainExpectedEntries() {
    Map<String, String> result = RootController.mapConcurrentHashMap();
    assertEquals("alpha", result.get("a"));
    assertEquals("beta", result.get("b"));
  }

  // --- Cas 5 : mapImmutableOf ---

  @Test
  void mapImmutableOf_shouldReturnImmutableMap() {
    Map<String, String> result = RootController.mapImmutableOf();
    assertEquals("alpha", result.get("a"));
    assertThrows(UnsupportedOperationException.class, () -> result.put("x", "y"));
  }

  // --- Cas 6 : mapImmutableEntries ---

  @Test
  void mapImmutableEntries_shouldReturnImmutableMap() {
    Map<String, String> result = RootController.mapImmutableEntries();
    assertEquals("alpha", result.get("a"));
    assertThrows(UnsupportedOperationException.class, () -> result.put("x", "y"));
  }

  // --- Cas 7 : mapGet ---

  @Test
  void mapGet_shouldReturnValue_whenKeyExists() {
    assertEquals("alpha", RootController.mapGet());
  }

  // --- Cas 8 : mapGetOrDefault ---

  @Test
  void mapGetOrDefault_shouldReturnDefault_whenKeyAbsent() {
    assertEquals("default", RootController.mapGetOrDefault());
  }

  // --- Cas 9 : mapContainsKey ---

  @Test
  void mapContainsKey_shouldReturnTrue_whenKeyExists() {
    assertTrue(RootController.mapContainsKey());
  }

  // --- Cas 10 : mapContainsValue ---

  @Test
  void mapContainsValue_shouldReturnTrue_whenValueExists() {
    assertTrue(RootController.mapContainsValue());
  }

  // --- Cas 11 : mapIterateEntrySet ---

  @Test
  void mapIterateEntrySet_shouldReturnKeyValuePairs() {
    List<String> result = RootController.mapIterateEntrySet();
    assertEquals(2, result.size());
    assertTrue(result.contains("a=alpha"));
    assertTrue(result.contains("b=beta"));
  }

  // --- Cas 12 : mapIterateKeySet ---

  @Test
  void mapIterateKeySet_shouldReturnKeys() {
    List<String> result = RootController.mapIterateKeySet();
    assertEquals(List.of("a", "b"), result);
  }

  // --- Cas 13 : mapIterateValues ---

  @Test
  void mapIterateValues_shouldReturnValues() {
    List<String> result = RootController.mapIterateValues();
    assertEquals(List.of("alpha", "beta"), result);
  }

  // --- Cas 14 : mapComputeIfAbsent ---

  @Test
  void mapComputeIfAbsent_shouldInsertComputedValue_whenKeyAbsent() {
    Map<String, Integer> result = RootController.mapComputeIfAbsent();
    assertEquals(5, result.get("hello"));
  }

  @Test
  void mapComputeIfAbsent_shouldNotOverwrite_whenKeyPresent() {
    java.util.HashMap<String, Integer> map = new java.util.HashMap<>();
    map.put("hello", 99);
    map.computeIfAbsent("hello", k -> k.length());
    assertEquals(99, map.get("hello"));
  }

  // --- Cas 15 : mapMerge ---

  @Test
  void mapMerge_shouldSumValues_whenKeyExists() {
    Map<String, Integer> result = RootController.mapMerge();
    assertEquals(3, result.get("a"));
  }

  // --- Cas 16 : mapReplaceAll ---

  @Test
  void mapReplaceAll_shouldTransformAllValues() {
    Map<String, String> result = RootController.mapReplaceAll();
    assertEquals("ALPHA", result.get("a"));
    assertEquals("BETA", result.get("b"));
  }

  // --- Cas 17 : mapNullKey ---

  @Test
  void mapNullKey_shouldAllowNullKeyInHashMap() {
    assertTrue(RootController.mapNullKey());
  }

  // --- Cas 18 : mapSize ---

  @Test
  void mapSize_shouldReturnCorrectCount() {
    assertEquals(3, RootController.mapSize());
  }

  // --- Cas 19 : mapPutIfAbsent ---

  @Test
  void mapPutIfAbsent_shouldNotOverwrite_whenKeyExists() {
    Map<String, String> result = RootController.mapPutIfAbsent();
    assertEquals("alpha", result.get("a"));
  }

  @Test
  void mapPutIfAbsent_shouldInsert_whenKeyAbsent() {
    Map<String, String> result = RootController.mapPutIfAbsent();
    assertEquals("beta", result.get("b"));
  }

  // --- Cas 20 : mapRemove ---

  @Test
  void mapRemove_shouldDeleteEntry() {
    Map<String, String> result = RootController.mapRemove();
    assertFalse(result.containsKey("a"));
    assertTrue(result.containsKey("b"));
  }
}
```

---

## Principes clés

- `Map<K,V>` représente une association clé → valeur, clé unique, valeurs éventuellement dupliquées
- `HashMap` : non ordonné, O(1) amorti, accepte une clé `null`
- `LinkedHashMap` : conserve l'ordre d'insertion
- `TreeMap` : trié par ordre naturel des clés, O(log n)
- `ConcurrentHashMap` : thread-safe, refuse `null` clé et valeur
- `Map.of()` : immutable, max 10 paires, refuse `null`
- `Map.ofEntries()` : immutable, sans limite de paires, refuse `null`
- `get()` retourne `null` si clé absente — préférer `getOrDefault()`
- `computeIfAbsent` : calcule et insère uniquement si clé absente
- `merge` : fusionne une valeur existante avec une fonction de remappage
- `replaceAll` : transforme toutes les valeurs en place
- `putIfAbsent` : n'écrase pas une valeur existante
